package com.tailbait.algorithm

import com.tailbait.data.database.entities.ScannedDevice

/**
 * Generates a "shadow key" -- a coarse, MAC-agnostic device profile
 * built from BLE properties that survive MAC address rotation.
 *
 * Two physical devices of the same make/model will share a shadow key.
 * This is intentional: the shadow system doesn't prove identity, it
 * identifies _types_ of devices and then uses persistence scoring
 * (how consistently exactly 1 device of this type appears) to infer
 * whether it's the same physical device following the user.
 *
 * ## Key Format
 * Human-readable, pipe-delimited, sorted components:
 * ```
 * B:FIND_MY|C:12|M:004C|P:-7|SEP:1|T:TRACKER|TR:1|U:FD6F
 * ```
 *
 * ## Specificity
 * More components = more specific = higher confidence when persistence
 * scoring produces a match. Minimum 2 components required.
 */
object ShadowKeyGenerator {

    /** Maximum number of possible components in a shadow key. */
    const val MAX_COMPONENTS = 8

    /** Minimum components for a usable shadow key. */
    private const val MIN_COMPONENTS = 2

    /**
     * Generate a shadow key from a device's stable BLE properties.
     *
     * @param device The scanned device to generate a key for.
     * @return Shadow key string, or null if fewer than [MIN_COMPONENTS] are available.
     */
    fun generate(device: ScannedDevice): String? {
        val components = mutableListOf<String>()

        device.manufacturerId?.let {
            if (it != 0) components.add("M:%04X".format(it))
        }

        device.deviceType?.let {
            if (it != "UNKNOWN") components.add("T:$it")
        }

        device.appleContinuityType?.let {
            components.add("C:%02X".format(it))
        }

        if (device.isTracker) {
            components.add("TR:1")
        }

        if (device.findMySeparated) {
            components.add("SEP:1")
        }

        device.beaconType?.let {
            components.add("B:$it")
        }

        device.txPowerLevel?.let {
            components.add("P:$it")
        }

        device.serviceUuids?.let { uuids ->
            if (uuids.isNotBlank()) {
                // Extract short UUIDs, sort for stability
                val shortUuids = uuids.split(",")
                    .map { it.trim().uppercase() }
                    .filter { it.isNotBlank() }
                    .map { uuid ->
                        if (uuid.startsWith("0000") && uuid.length >= 8) {
                            uuid.substring(4, 8)
                        } else {
                            uuid.take(8)
                        }
                    }
                    .sorted()
                    .joinToString(",")
                if (shortUuids.isNotBlank()) {
                    components.add("U:$shortUuids")
                }
            }
        }

        if (components.size < MIN_COMPONENTS) return null

        return components.sorted().joinToString("|")
    }

    /**
     * Calculate specificity score for a shadow key.
     *
     * More components means the key is more specific to a narrow class
     * of devices, which increases confidence in persistence scoring.
     *
     * @param shadowKey A shadow key string generated by [generate].
     * @return Score between 0.0 and 1.0 (componentCount / MAX_COMPONENTS).
     */
    fun specificityScore(shadowKey: String): Float {
        val componentCount = shadowKey.split("|").size
        return (componentCount.toFloat() / MAX_COMPONENTS).coerceAtMost(1.0f)
    }
}
