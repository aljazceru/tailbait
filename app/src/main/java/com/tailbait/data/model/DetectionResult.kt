package com.tailbait.data.model

import com.tailbait.data.database.entities.Location
import com.tailbait.data.database.entities.ScannedDevice

/**
 * Represents the result of running the stalking detection algorithm on a device.
 *
 * This data class encapsulates all the information about a potentially suspicious
 * device, including the device details, the locations where it was detected,
 * calculated threat metrics, and a human-readable explanation of why the device
 * was flagged.
 *
 * Detection Results are generated by the DetectionAlgorithm and used to:
 * - Create alert notifications for the user
 * - Populate the alerts UI with detailed threat information
 * - Store detection history in the AlertHistory database
 * - Generate threat analytics and statistics
 *
 * Threat Score Breakdown:
 * The threat score is a normalized value between 0.0 and 1.0 calculated by
 * the ThreatScoreCalculator based on multiple factors:
 * - Location count (0.3): More locations = higher threat
 * - Distance factor (0.25): Greater distances = higher threat
 * - Time correlation (0.2): Longer tracking period = higher threat
 * - Consistency (0.15): Regular appearances = higher threat
 * - Device type (0.1): Mobile devices = higher threat
 *
 * Threat Levels:
 * - CRITICAL: score >= 0.9 (Very high confidence of stalking)
 * - HIGH: score >= 0.75 (High confidence of stalking)
 * - MEDIUM: score >= 0.6 (Moderate confidence of stalking)
 * - LOW: score >= 0.5 (Low confidence, but worth flagging)
 *
 * @property device The suspicious device that was detected
 * @property locations List of distinct locations where the device was seen
 * @property threatScore Normalized threat score (0.0 - 1.0)
 * @property maxDistance Maximum distance in meters between any two locations
 * @property avgDistance Average distance in meters between all location pairs
 * @property detectionReason Human-readable explanation of why this device was flagged
 * @property timestamp Timestamp when this detection was made
 * @property detectionId Unique identifier for this detection (for tracking/storage)
 */
data class DetectionResult(
    val device: ScannedDevice,
    val locations: List<Location>,
    val threatScore: Double,
    val maxDistance: Double,
    val avgDistance: Double,
    val detectionReason: String,
    val timestamp: Long = System.currentTimeMillis(),
    val detectionId: String = generateDetectionId(device.id, timestamp)
) {
    /**
     * Get the threat level as a human-readable string.
     *
     * @return Threat level string (CRITICAL, HIGH, MEDIUM, LOW)
     */
    fun getThreatLevel(): ThreatLevel {
        return when {
            threatScore >= 0.9 -> ThreatLevel.CRITICAL
            threatScore >= 0.75 -> ThreatLevel.HIGH
            threatScore >= 0.6 -> ThreatLevel.MEDIUM
            else -> ThreatLevel.LOW
        }
    }

    /**
     * Get the time span covered by the detections.
     *
     * @return Time span in milliseconds
     */
    fun getTimeSpan(): Long {
        if (locations.isEmpty()) return 0
        val oldest = locations.minByOrNull { it.timestamp }?.timestamp ?: 0
        val newest = locations.maxByOrNull { it.timestamp }?.timestamp ?: 0
        return newest - oldest
    }

    /**
     * Get a summary string for quick display.
     *
     * @return Summary string
     */
    fun getSummary(): String {
        return "${device.name ?: device.address} - ${getThreatLevel().displayName} threat"
    }

    /**
     * Check if this detection should trigger an alert notification.
     *
     * @param minThreatScore Minimum score threshold for alerts
     * @return True if should alert
     */
    fun shouldAlert(minThreatScore: Double = 0.5): Boolean {
        return threatScore >= minThreatScore
    }

    companion object {
        /**
         * Generate a unique detection ID.
         *
         * @param deviceId Device ID
         * @param timestamp Detection timestamp
         * @return Unique detection ID
         */
        private fun generateDetectionId(deviceId: Long, timestamp: Long): String {
            return "DET_${deviceId}_$timestamp"
        }
    }
}

/**
 * Threat level enumeration for categorizing detection severity.
 */
enum class ThreatLevel(val displayName: String, val score: Double) {
    CRITICAL("Critical", 0.9),
    HIGH("High", 0.75),
    MEDIUM("Medium", 0.6),
    LOW("Low", 0.5);

    companion object {
        /**
         * Get threat level from a threat score.
         *
         * @param score Threat score (0.0 - 1.0)
         * @return Corresponding threat level
         */
        fun fromScore(score: Double): ThreatLevel {
            return when {
                score >= CRITICAL.score -> CRITICAL
                score >= HIGH.score -> HIGH
                score >= MEDIUM.score -> MEDIUM
                else -> LOW
            }
        }
    }
}

/**
 * Detailed threat score breakdown for analytics and debugging.
 *
 * This class provides a detailed breakdown of how the threat score was calculated,
 * which can be useful for:
 * - Showing users why a device was flagged
 * - Tuning the scoring algorithm
 * - Analytics and reporting
 * - Debugging false positives/negatives
 *
 * @property locationCountScore Score from number of locations (0.0 - 0.3)
 * @property distanceScore Score from distance between locations (0.0 - 0.25)
 * @property timeCorrelationScore Score from time span of detections (0.0 - 0.2)
 * @property consistencyScore Score from regularity of appearances (0.0 - 0.15)
 * @property deviceTypeScore Score from device type suspicion (0.0 - 0.1)
 * @property totalScore Sum of all scores (0.0 - 1.0)
 */
data class ThreatScoreBreakdown(
    val locationCountScore: Double,
    val distanceScore: Double,
    val timeCorrelationScore: Double,
    val consistencyScore: Double,
    val deviceTypeScore: Double,
    val totalScore: Double
) {
    /**
     * Get a human-readable explanation of the score breakdown.
     *
     * @return Explanation string
     */
    fun getExplanation(): String {
        return buildString {
            appendLine("Threat Score Breakdown:")
            appendLine("- Locations: ${formatScore(locationCountScore)} / 0.30")
            appendLine("- Distance: ${formatScore(distanceScore)} / 0.25")
            appendLine("- Time Pattern: ${formatScore(timeCorrelationScore)} / 0.20")
            appendLine("- Consistency: ${formatScore(consistencyScore)} / 0.15")
            appendLine("- Device Type: ${formatScore(deviceTypeScore)} / 0.10")
            appendLine("Total: ${formatScore(totalScore)} / 1.00")
        }
    }

    private fun formatScore(score: Double): String {
        return "%.2f".format(score)
    }
}
